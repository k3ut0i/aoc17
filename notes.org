* Advent of Code 2017
** Perl Version
*** DONE Day 1
#+begin_src perl :exports both :var infile='inputs/day1'
  use lib './src';
  use Day1;
  open my $fh, '<', $infile
    or die "Could not open file $infile: $!\n";
  chomp(my $str = <$fh>);
  [Day1::captcha2($str), Day1::captcha_half_way($str)];
#+end_src

#+RESULTS:
| 1047 |
|  982 |


The starting value bug was due to newline at the end of the input string.
*** DONE Day 2
Simple ~mapreduce~ for an sequence of arrays.
#+begin_src perl :exports both :var infile='inputs/day2'
  use lib './src';
  use Day2;
  [ Day2::crunch_spreadsheet($infile,
			     \&Day2::checksum,   # map for each line
			     sub {$_[0]+$_[1]}), # reduce with plus
    Day2::crunch_spreadsheet($infile,
			     \&Day2::checksum_div,
			     sub {$_[0] + $_[1]}),
  ]

#+end_src

#+RESULTS:
| 47623 |
|   312 |

If I assume that we need both the answers, the above method of iterating in the file might be inefficient.
In the context of correct method being part2, it might be a good solution.
*** DONE Day 3
    CLOSED: [2021-01-27 Wed 10:12]
I have previously spent too long trying to arrive at a general
boundary condition for this problem. Now that I have concentrated
on it and got it right, my confustion b/w ~^~ and ~**~ as perl 
power operator lead me to get a better grip on the problem to
arrive at the conclusion that ~^~ is not the operator I was
looking for.
#+begin_src perl :exports both :var num=277678
  use lib './src';
  use Day3;
  # a X-Y impl
  # Day3::manhattan_dis(Day3::n_to_xy($num))
  [Day3::getdis($num), Day3::stress_test(sub {$_[0] <= $num})]
#+end_src

#+RESULTS:
|    475 |
| 279138 |

*** Day 4
A simple filter.
#+begin_src perl :exports both :var infile='inputs/day4'
  use lib './src';
  use Day4;

  open my $fh, '<', $infile  or die "Couldn't open $infile: $!";
  my $nvalid1 = 0; my $nvalid2 = 0;
  while (<$fh>) {
    chomp; my @a = split;
    $nvalid1++ if (Day4::isvalid(\@a, sub {$_[0] eq $_[1]})) ;
    $nvalid2++ if Day4::isvalid(\@a, sub {$_[0] eq $_[1] or
					    Day4::is_anagram($_[0], $_[1])});
  }
  [$nvalid1, $nvalid2];
#+end_src

#+RESULTS:
| 325 |
| 119 |
Wasted too much time on a bug in ~is_anagram~. Should have iterated over the union of chars in two strings.
** Agda Version
*** Day 1
 Even the basic IO is so convoluted that to run a hello world program it compiles 130 modules. There are a lot of utilities not defined here. I am trying to define a read-number function from a string. Haven't used this in the problem.

 Got stuck trying to destruct on equality of two characters.  By luck found out about ~Data.Char.â‰ˆ?~ which is the decidable instance of character equality. So I have partly solved the first part of the problem. I did not compare the last and first characters of the input in the program, So I have checked it manually (and added 8) which gave me the correct answer.
    #+begin_src sh :exports results :results output verbatim
      cd src/
      ./day1
    #+end_src

    #+RESULTS:
    : 1039
    : 952

 Completed the second part too, using ~splitAt~ function and rotating the list in half. I am only tripping up at IO and using Coinduction with INFINITY, SHARP and FLAT constructors. Need more familiarity with all of these.
*** Day 2
 I need to get more familiar using generic abstractions. I keep writing small utilities which probably can be built simply using stdlib.

 #+begin_src sh :exports results :results output verbatim
   cd src/
   ./day2
 #+end_src

 #+RESULTS:
 : 47623
 : 312
