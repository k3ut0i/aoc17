* Advent of Code 2017
** Perl Version
*** DONE Day 1
#+begin_src perl :exports both :var infile='inputs/day1'
  use lib 'lib';
  use Day1;
  open my $fh, '<', $infile
    or die "Could not open file $infile: $!\n";
  chomp(my $str = <$fh>);
  [Day1::captcha2($str), Day1::captcha_half_way($str)];
#+end_src

#+RESULTS:
| 1047 |
|  982 |


The starting value bug was due to newline at the end of the input string.
*** DONE Day 2
Simple ~mapreduce~ for an sequence of arrays.
#+begin_src perl :exports both :var infile='inputs/day2'
  use lib 'lib';
  use Day2;
  [ Day2::crunch_spreadsheet($infile,
			     \&Day2::checksum,   # map for each line
			     sub {$_[0]+$_[1]}), # reduce with plus
    Day2::crunch_spreadsheet($infile,
			     \&Day2::checksum_div,
			     sub {$_[0] + $_[1]}),
  ]

#+end_src

#+RESULTS:
| 47623 |
|   312 |

If I assume that we need both the answers, the above method of iterating in the file might be inefficient.
In the context of correct method being part2, it might be a good solution.
*** DONE Day 3
    CLOSED: [2021-01-27 Wed 10:12]
I have previously spent too long trying to arrive at a general
boundary condition for this problem. Now that I have concentrated
on it and got it right, my confustion b/w ~^~ and ~**~ as perl 
power operator lead me to get a better grip on the problem to
arrive at the conclusion that ~^~ is not the operator I was
looking for.
#+begin_src perl :exports both :var num=277678
  use lib 'lib';
  use Day3;
  # a X-Y impl
  # Day3::manhattan_dis(Day3::n_to_xy($num))
  [Day3::getdis($num), Day3::stress_test(sub {$_[0] <= $num})]
#+end_src

#+RESULTS:
|    475 |
| 279138 |

*** DONE Day 4
    CLOSED: [2021-01-27 Wed 22:32]
A simple filter.
#+begin_src perl :exports both :var infile='inputs/day4'
  use lib 'lib';
  use Day4;

  open my $fh, '<', $infile  or die "Couldn't open $infile: $!";
  my $nvalid1 = 0; my $nvalid2 = 0;
  while (<$fh>) {
    chomp; my @a = split;
    $nvalid1++ if (Day4::isvalid(\@a, sub {$_[0] eq $_[1]})) ;
    $nvalid2++ if Day4::isvalid(\@a, \&Day4::is_anagram);
  }
  [$nvalid1, $nvalid2];
#+end_src

#+RESULTS:
| 325 |
| 119 |
Wasted too much time on a bug in ~is_anagram~. Should have iterated over the union of chars in two strings.
Also ~is_anagram~ is a superset of ~eq~. Why was I dumbly checking for equality or anagram?
*** DONE Day 5
    CLOSED: [2021-01-28 Fri 22:02]
Simple step simulation.
#+begin_src perl :exports both :var infile='inputs/day5'
  use lib 'lib';
  use Day5;
  use Clone 'clone';

  open my $fh, '<', $infile or die "File Error: $infile $!";
  my @jumps;
  while (<$fh>) {  chomp; push @jumps, $_; }
  my $jumps2 = clone(\@jumps);
  my $i = 0; my $nsteps1 = 0; my $nsteps2 = 0;
  while ($i < scalar @jumps) {
    $i = Day5::step_inst(\@jumps, $i, sub {$_[0]+1}); $nsteps1++;
  }
  $i = 0;
  while ($i < scalar @jumps) {
    $i = Day5::step_inst($jumps2, $i, sub {$_[0] >= 3 ? ($_[0]-1) : ($_[0]+1)});
    $nsteps2++;
  }
  [$nsteps1,$nsteps2];
#+end_src

#+RESULTS:
|   360603 |
| 25347697 |

Bug Fixed: I stupidly cloned a zero array. I would have caught it earlier if I just used ~$i < scalar @$jumps2~ in the second while loop.
*** DONE Day 6
    CLOSED: [2021-01-31 Sun 17:29]
Iterative simulation. I used a hash for fast state lookup. State is converted to a string to work with a hash.
#+begin_src perl :exports both :var infile='inputs/day6'
  use lib 'lib';
  use Day6;
  sub run {
    open my $fh, '<', $_[0] or die "File $infile: $!";
    chomp(my $inline = <$fh>);
    my @state = split(/\s+/, $inline);
    my $state_str = join(':', @state);
    my %seen; my $step_num = 0;

    until (defined $seen{$state_str}) {
      $seen{$state_str} = $step_num;
      Day6::step_redist_x(\@state);
      $state_str = join(':', @state);
      $step_num++;
    }
    return [$step_num, $step_num - $seen{$state_str}]
  }

  run($infile);
#+end_src

#+RESULTS:
| 12841 |
|  8038 |
*** DONE Day 7
    CLOSED: [2021-02-03 Wed 11:36]
I always struggle to write tree recursive code iteratively.
- For part one, I just calculated a node with no parents.
- For the second part, if the network is constructed completely, traverse from the root node by choosing the node with different weight than the others. We will reach a node that has all children of the same weight. This node weight must be adjusted so that the cumulative is equal to it's siblings.  
#+begin_src perl :exports both :var infile='inputs/day7' :results output raw
  use lib 'lib';
  use Day7;
  open my $fh, '<', $infile or die "File error $infile: $!";
  my @lines;
  for (<$fh>) {
    chomp; push @lines, $_;
  }
  # simple way to find a root
  # my $root = Day7::find_root(\@lines);
  my ($network, $roots) = Day7::create_network(\@lines);
  my ($error_node, $error_correction) = Day7::find_error_node($network, $roots->[0]);
  die "Undefined Error node" unless defined $error_node;
  my $dotfile = 'outputs/day7.dot'; my $img = 'outputs/day7.jpg';
  Day7::write_network_graphviz($network, $dotfile, [$error_node]);
  print <<OUT;
  : Root node is $roots->[0]
  : Error node is $error_node with new weight ${\ ($network->{$error_node}{weight} - $error_correction)}
  OUT
  print "A Radial Visualization of this network: error node in red.\n[[file:$img]]\n"
    unless system(qq(twopi -Tjpg -o $img $dotfile))
#+end_src

#+RESULTS:
: Root node is svugo
: Error node is sphbbz with new weight 1152
A Radial Visualization of this network: error node in red.
[[file:outputs/day7.jpg]]
*** TODO Day 8
Simple simulation of a sequence of conditional evaluations.
#+begin_src perl :exports both :var infile='inputs/day8'
  use lib 'lib';
  use Day8;
  use List::Util qw(max);

  open my $fh, '<', $infile or die "File error $infile: $!";
  my %context = (); my $max_ever = 0;
  while (<$fh>) {
    chomp; next unless $_;
    my @inst = Day8::parse_inst($_);
    my $val = Day8::eval_inst(\@inst, \%context);
    $max_ever = $val if defined $val and $val > $max_ever;
  }

  [(max values %context), $max_ever];
#+end_src

#+RESULTS:
| 6828 |
| 7234 |

** Agda Version
*** Day 1
 Even the basic IO is so convoluted that to run a hello world program it compiles 130 modules. There are a lot of utilities not defined here. I am trying to define a read-number function from a string. Haven't used this in the problem.

 Got stuck trying to destruct on equality of two characters.  By luck found out about ~Data.Char.â‰ˆ?~ which is the decidable instance of character equality. So I have partly solved the first part of the problem. I did not compare the last and first characters of the input in the program, So I have checked it manually (and added 8) which gave me the correct answer.
    #+begin_src sh :exports results :results output verbatim
      cd src/
      ./day1
    #+end_src

    #+RESULTS:
    : 1039
    : 952

 Completed the second part too, using ~splitAt~ function and rotating the list in half. I am only tripping up at IO and using Coinduction with INFINITY, SHARP and FLAT constructors. Need more familiarity with all of these.
*** Day 2
 I need to get more familiar using generic abstractions. I keep writing small utilities which probably can be built simply using stdlib.

 #+begin_src sh :exports results :results output verbatim
   cd src/
   ./day2
 #+end_src

 #+RESULTS:
 : 47623
 : 312
